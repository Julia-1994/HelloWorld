## 常见数据结构与算法

### 常用数据结构

数组：数据连续，可以通过索引随机访问。增加和删除复杂度N（需要改变元素的内存）；根据索引查找复杂度1，根据值查找复杂度N。有序的存储方式。

链表：非连续的存储：增加删除都是1，查找是N。

哈希表：了解散列函数，哈希碰撞-解决方法是使用链表存储碰撞的元素（或者哈希数组扩容）。哈希表增删查的复杂度都是1，消耗内存空间。

~~~js
let arr = new Array(10).fill('');
function hash(s) {
  return s.charCodeAt() * 37 % 10;
}
~~~

树：必须掌握（字符串转换成树，AST），DOM节点树的操作；

二叉树可以转换成数组。每一层都是2N次方。

左边的元素是 2N，右边的元素是 2N(次方) + 1

### 常用算法

排序（冒泡、快速）

搜索（二分）

回溯、贪心、动态规划

递归（数组打平、括号匹配，HTML标签匹配等、树计算）

~~~js
let app = document.getElementById('app');
let fn = (node) => {console.log(node);};
walk(app, fn);

function walk(node, func = () => {}) {
  if (node instanceof window.Node) {
    _walk(node, func);
  }
  return node;
}

function _walk(node, func) {
  if (func(node) !== false) {
    node = node.firstChild;
    while(node) {
      _walk(node, func);
      node = node.nextSibling;
    }
  }
}
~~~

## 参考书

入门：我的第一本算法书、啊哈算法、图解HTTP，图解TCP

经典教材：算法-第四版（一本书看了三个月，习题全部看一次）

主题阅读法：看一个知识点，只学习这个知识点；不会被其他的打扰

不断刷题才能提高算法：LeetCode 按照标签一个一个学习

树是复杂的列表，所以把列表各种操作熟练，并在工作中使用这些知识点

常见算法知识点固定，目标明确

任何高级技能，需要长时间练习；我们常常放大短期学习的威力，缩小长期学习的威力。

## 习题

### 00 数组扁平化

递归

~~~js
function flat(array) {
  let res = [];
  array.forEach((item) => {
    if (Array.isArray(item)) {
      res = res.concat(flat(item));
    } else {
      res.push(item);
    }
  });
  return res;
}
~~~

### 01 两数之和 

twoSum 使用哈希表存储目标索引，循环一次

~~~js
var twoSum = function(nums, target) {
  let obj = {};
  for (let i = 0; i < nums.length; i++) {
    let item = nums[i];
    if (item in obj) {
      return [obj[item], i]; // find two number and return index
    } else {
      obj[target - item] = i;
    }
  }
};
~~~

### 46 全排列（回溯算法）

```js
function backtrack(list, temp, nums) {
  // 递归的结束条件
  if (temp.length === nums.length) {
    return list.push([...temp]);
  }
  for (let i = 0; i < nums.length; i++) {
    if (temp.includes(nums[i])) {
      continue;
    }
    // 回溯（放进去，执行，抛出来）
    temp.push(nums[i]);
    backtrack(list, temp, nums);
    temp.pop();
  }
}

var permute = function(nums) {
  let list = [];
  let temp = []
  backtrack(list, temp, nums);
  return list;
}
```

### 94 二叉树的中序遍历

~~~js
/**
 * @param {TreeNode} root
 * @return {number[]}
 * 中序遍历：左根右
 */
var inorderTraversal = function(root) {
  if (!root || !root.val) {
    return [];
  }
  var list = [];
  runNode(root, list);
  return list;
};

function runNode(node, list) {
  if (node.left) {
    runNode(node.left, list)
  }
  list.push(node.val);
  if (node.right) {
    runNode(node.right, list)
  }
}
~~~

### 100 相同的树

~~~js
var isSameTree = function(p, q) {
  if (p == null && q == null) {
    return true;
  } else if (p == null || q == null) {
    return false;
  } else if (p.val !== q.val) {
    return false;
  } else {
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
  }
};
~~~

判断节点的值是否相等；递归判断子节点是否相等


### 104 二叉树的最大深度

~~~js
var treeDepth = (node) => {
  if (!node) {
    return 1;
  }
  return Math.max(treeDepth(node.left), treeDepth(node.right));
} 
~~~

### 141 环形列表

~~~js
// 环形列表不能通过值记录，可能列表中存在重复值
// 下面适合没有重复元素的链表
var hasCycle = function(head) {
  if (!head) {
    return false;
  }
  let val = head.val;
  head.isRun = true;

  while (head && head.next) {
    head = head.next;
    val = head.val
    if (!head.isRun) {
      head.isRun = true;
    } else {
      return true;
    }
  }
  return false;
}
~~~

如何判断一个节点已经被遍历了？能否设置一个属性为true，这样会更改原始节点，看看有没有更好的方法。现在需要循环列表。最好的办法是设置一个快指针，一个慢指针，如果指针重复，那么就有环形结构。

下面是较难的回溯算法：
51-N皇后 
8皇后

